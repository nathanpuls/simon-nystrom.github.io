{"pageProps":{"post":{"html":"<p>We will build a simpler version of <a href=\"https://todo.newcurrent.se/\">this</a> in this blog post. It goes through the steps of setting up an <a href=\"https://elm-lang.org/\"><code>Elm</code></a> project and the benefits of using <code>Elm</code> on the front-end and how it provides some really nice help for you as a developer.</p>\n<hr>\n<h1 id=\"prerequisites\">Prerequisites</h1>\n<p>You need a few things to get started. Knowledge of JavaScript, HTML and CSS is expected as this guide skips over all those steps and I recommend following my <a href=\"https://newcurrent.se/blog/containerized-development-environment\">devcontainer guide</a> and using an <code>Elm</code> container (instead of a <code>Node</code> container like that guide) since that eliminates any sort of installation process for you. For this tutorial I will be using a devcontainer, but if you want to install <code>Elm</code> on your local filesystem you can do so too by following the steps <a href=\"https://guide.elm-lang.org/install/elm.html\">here</a>. Knowing the basics of some functional programming concepts won&#39;t hurt either ðŸ˜Š.</p>\n<hr>\n<h1 id=\"the-elm-architecture\">The Elm architecture</h1>\n<p><code>Elm</code> uses something it refers to as <a href=\"https://guide.elm-lang.org/architecture/\"><code>The Elm Architecture</code></a>. This architecture is really useful when dealing with transformations of data and reactive updates. Perhaps you&#39;ve heard of a popular state management library called Redux? The Redux architecture is inspired by the one used in Elm. This pattern is built into <code>Elm</code>, so no need for a third-party lib.</p>\n<p>The Elm Architecture builds on three core principles:</p>\n<ul>\n<li>Model - The model (often called state in other frameworks) of your application</li>\n<li>View - Convert the model to HTML</li>\n<li>Update - Update the model</li>\n</ul>\n<p>You can already see how this architecture works: The model turns into HTML that is then acted upon (updated) which then triggers an update and the HTML is re-rendered etc. You can think of this as a render loop.</p>\n<hr>\n<h1 id=\"creating-a-basic-page\">Creating a basic page</h1>\n<p>Let&#39;s start by initializing the project, this is done by running the following:</p>\n<pre><div class=\"copy-me\" onclick=\"copyCode(this)\">Copy</div><code>elm init</code></pre><p>This creates a folder called <code>src</code> and a file called <code>elm.json</code>. You can think of this like the <code>package.json</code> for a <code>node</code> project, basically it describes your project and its dependencies.</p>\n<p>Let&#39;s create our first page, create a page called <code>Main.elm</code> and place it in the <code>src</code> directory.</p>\n<pre><div class=\"copy-me\" onclick=\"copyCode(this)\">Copy</div><code><span class=\"hljs-comment\">-- Don&#x27;t worry about this line, we can expose everything because</span>\n<span class=\"hljs-comment\">-- we will only be using this file, so exposing something doesn&#x27;t</span>\n<span class=\"hljs-comment\">-- matter</span>\n<span class=\"hljs-keyword\">module</span> Main <span class=\"hljs-keyword\">exposing</span> (..)\n\n<span class=\"hljs-comment\">-- Imports that we need the run our initial example</span>\n<span class=\"hljs-keyword\">import</span> Browser\n<span class=\"hljs-keyword\">import</span> Html <span class=\"hljs-keyword\">exposing</span> (<span class=\"hljs-type\">Html</span>, div, text)\n\n<span class=\"hljs-comment\">-- Initialize the empty record, this is used by Elm</span>\n<span class=\"hljs-comment\">-- to create the initial model</span>\n<span class=\"hljs-title\">init</span> : <span class=\"hljs-type\">Model</span>\n<span class=\"hljs-title\">init</span> =\n     <span class=\"hljs-type\">Model</span>\n\n\n<span class=\"hljs-comment\">-- We don&#x27;t have a type annotation here, which is normally</span>\n<span class=\"hljs-comment\">-- recommended but that&#x27;s okay because we don&#x27;t have to worry</span>\n<span class=\"hljs-comment\">-- about what this function returns</span>\n<span class=\"hljs-title\">main</span> =\n    <span class=\"hljs-type\">Browser</span>.sandbox { init = init, update = update, view = view }\n\n\n<span class=\"hljs-comment\">-- Right now, our Model is just an empty Record</span>\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-keyword\">alias</span> <span class=\"hljs-type\">Model</span> =\n    {}\n\n\n<span class=\"hljs-comment\">-- Prepare the Msg type that will be used to trigger</span>\n<span class=\"hljs-comment\">-- updates in the render loop</span>\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-type\">Msg</span>\n    = <span class=\"hljs-type\">Never</span>\n\n\n<span class=\"hljs-comment\">-- Right now, whatever Msg we get we won&#x27;t update the model</span>\n<span class=\"hljs-comment\">-- Msg -&gt; Model -&gt; Model simplified means this function takes</span>\n<span class=\"hljs-comment\">-- in a Msg and a Model and produces a new Model.</span>\n<span class=\"hljs-title\">update</span> : <span class=\"hljs-type\">Msg</span> -&gt; <span class=\"hljs-type\">Model</span> -&gt; <span class=\"hljs-type\">Model</span>\n<span class=\"hljs-title\">update</span> msg model =\n    <span class=\"hljs-type\">Model</span>\n\n\n<span class=\"hljs-comment\">-- Our view is a function that takes the model and produces Html</span>\n<span class=\"hljs-comment\">-- and messages that in turn trigger the update function</span>\n<span class=\"hljs-title\">view</span> : <span class=\"hljs-type\">Model</span> -&gt; <span class=\"hljs-type\">Html</span> <span class=\"hljs-type\">Msg</span>\n<span class=\"hljs-title\">view</span> model =\n    div [] [ text <span class=\"hljs-string\">&quot;Hello world&quot;</span> ]</code></pre><p>Now that we have our <code>src/Main.elm</code> file set up, let&#39;s try to run our code and view it in a browser. We&#39;ll use <code>elm reactor</code> for this. <code>elm reactor</code> allows you to inspect your program in a file browser in the browser and whatever file you click on gets compiled and rendered, try it out by visiting <a href=\"http://localhost:8000\">http://localhost:8000</a> and browsing to <code>src/Main.elm</code> after running:</p>\n<pre><div class=\"copy-me\" onclick=\"copyCode(this)\">Copy</div><code>elm reactor</code></pre><p>This should show you an HTML page that only contains the string <em>Hello world</em>.</p>\n<hr>\n<h1 id=\"adding-an-input-field-and-tying-it-to-our-model\">Adding an Input field and tying it to our Model</h1>\n<p>Our page is useless at the moment. All it does is display a static string and since we want to create a todo tracker, let&#39;s start by adding an input field where we can type our todos. Modify the <code>view</code> function to look like this instead:</p>\n<pre><div class=\"copy-me\" onclick=\"copyCode(this)\">Copy</div><code><span class=\"hljs-title\">view</span> model =\n    div []\n        [ input [] []\n        ]</code></pre><p>Also make sure you add <code>input</code> as an exposed field near the start of the file:</p>\n<pre><div class=\"copy-me\" onclick=\"copyCode(this)\">Copy</div><code><span class=\"hljs-keyword\">import</span> Html <span class=\"hljs-keyword\">exposing</span> (<span class=\"hljs-type\">Html</span>, div, input, text)</code></pre><p>These HTML functions that correspond to HTML element names are functions that take two parameters, one list of attributes and one list of children, so our example with the updated model would generate HTML equal to this:</p>\n<pre><div class=\"copy-me\" onclick=\"copyCode(this)\">Copy</div><code><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> /&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></code></pre><p>Now, our <code>input</code> can&#39;t really do anything, so we need to tie some behavior to it. Let&#39;s create a type of <code>Msg</code> for that, call it <code>UpdateInput</code>. Change the <code>type Msg</code> we created earlier to look like this:</p>\n<pre><div class=\"copy-me\" onclick=\"copyCode(this)\">Copy</div><code><span class=\"hljs-keyword\">type</span> <span class=\"hljs-type\">Msg</span>\n    = <span class=\"hljs-type\">UpdateInput</span> <span class=\"hljs-type\">String</span></code></pre><p>We also need to let our <code>Model</code> know that we need to track the state of a field:</p>\n<pre><div class=\"copy-me\" onclick=\"copyCode(this)\">Copy</div><code><span class=\"hljs-keyword\">type</span> <span class=\"hljs-keyword\">alias</span> <span class=\"hljs-type\">Model</span> =\n    { value : <span class=\"hljs-type\">String</span> }</code></pre><p>The <code>Elm</code> compiler will complain now, because the type of our <code>Model</code> changed, so our <code>init</code> function needs to handle this new type of model:</p>\n<pre><div class=\"copy-me\" onclick=\"copyCode(this)\">Copy</div><code><span class=\"hljs-title\">init</span> =\n    { value = <span class=\"hljs-string\">&quot;&quot;</span> }</code></pre><p>And let&#39;s have our <code>input</code> fire the event when it&#39;s changed, let&#39;s also create a new <code>div</code> element to display whatever the value of our <code>model.value</code> is:</p>\n<pre><div class=\"copy-me\" onclick=\"copyCode(this)\">Copy</div><code><span class=\"hljs-comment\">-- Make sure to import the onInput event near the top of the file</span>\n<span class=\"hljs-keyword\">import</span> Html.Events <span class=\"hljs-keyword\">exposing</span> (onInput)\n\n<span class=\"hljs-comment\">-- ...</span>\n\n<span class=\"hljs-title\">view</span> model =\n    div []\n        [ input [ onInput <span class=\"hljs-type\">UpdateInput</span> ] []\n        , div [] [text model.value]\n        ]</code></pre><p>Now we need to let our <code>update</code> function react to this type of <code>Msg</code>:</p>\n<pre><div class=\"copy-me\" onclick=\"copyCode(this)\">Copy</div><code><span class=\"hljs-title\">update</span> msg model =\n    <span class=\"hljs-keyword\">case</span> msg <span class=\"hljs-keyword\">of</span>\n        <span class=\"hljs-comment\">-- Whenever we get the UpdateInput message, assign the new value to our state&#x27;s</span>\n        <span class=\"hljs-comment\">-- value and set that to be the new value. Whatever update returns is the new</span>\n        <span class=\"hljs-comment\">-- state of the application</span>\n        <span class=\"hljs-type\">UpdateInput</span> input -&gt;\n            { value = input }</code></pre><p>Run your app again and you should see that whatever you type into the <code>input</code> field is reflected on a line below.</p>\n<hr>\n<h1 id=\"creating-a-type-for-our-todo\">Creating a type for our Todo</h1>\n<p>We&#39;ve come pretty far already, our next step should be preparing the <code>type</code> needed by our application to track Todo items.</p>\n<p>Let&#39;s create a Todo alias type, this let&#39;s you treat the type Todo as a record consisting of the fields within:</p>\n<pre><div class=\"copy-me\" onclick=\"copyCode(this)\">Copy</div><code><span class=\"hljs-keyword\">type</span> <span class=\"hljs-keyword\">alias</span> <span class=\"hljs-type\">Todo</span> =\n    { id : <span class=\"hljs-type\">Int</span>, task : <span class=\"hljs-type\">String</span>, isComplete : <span class=\"hljs-type\">Bool</span> }</code></pre><p>Our model should track the Todos, so that we can display them:</p>\n<pre><div class=\"copy-me\" onclick=\"copyCode(this)\">Copy</div><code><span class=\"hljs-keyword\">type</span> <span class=\"hljs-keyword\">alias</span> <span class=\"hljs-type\">Model</span> =\n    { value : <span class=\"hljs-type\">String</span>, todos : <span class=\"hljs-type\">List</span> <span class=\"hljs-type\">Todo</span> }</code></pre><p>Again, the power of static typing will give two handy errors for us to fix, since our <code>Model</code> now contains one more field, we need to update both the <code>init</code> and <code>update</code> function:</p>\n<pre><div class=\"copy-me\" onclick=\"copyCode(this)\">Copy</div><code><span class=\"hljs-title\">init</span> =\n    <span class=\"hljs-comment\">-- Let the todo list be empty to start with</span>\n    { value = <span class=\"hljs-string\">&quot;&quot;</span>, todos = [] }\n\n<span class=\"hljs-comment\">-- ...</span>\n\n<span class=\"hljs-title\">update</span> msg model =\n    <span class=\"hljs-keyword\">case</span> msg <span class=\"hljs-keyword\">of</span>\n        <span class=\"hljs-type\">UpdateInput</span> input -&gt;\n            <span class=\"hljs-comment\">-- This is syntax sugar to let Elm know that when</span>\n            <span class=\"hljs-comment\">-- this message is fired, the model should stay</span>\n            <span class=\"hljs-comment\">-- unmodified except for the value property that</span>\n            <span class=\"hljs-comment\">-- should be set to the new value of the input field</span>\n            { model | value = input }</code></pre><p>That&#39;s great. We&#39;ve added a new type and handled the addition of it. You can&#39;t interact with it at all yet though, let&#39;s make that happen in the next section.</p>\n<hr>\n<h1 id=\"adding-todos-to-our-state\">Adding Todos to our state</h1>\n<p>First, we need a button we can press so that the value of our input is added as a todo in our Todo list.</p>\n<p>Let&#39;s start by defining a new type of message:</p>\n<pre><div class=\"copy-me\" onclick=\"copyCode(this)\">Copy</div><code><span class=\"hljs-keyword\">type</span> <span class=\"hljs-type\">Msg</span>\n    = <span class=\"hljs-type\">UpdateInput</span> <span class=\"hljs-type\">String</span>\n    | <span class=\"hljs-type\">AddTodo</span></code></pre><p>You&#39;ll notice our code has another error now. This is the beauty of <code>Elm</code>. You should see a compiler error telling you the following:</p>\n<p><img src=\"/images/elm/compiler_error.png\" alt=\"Compiler error in Elm\"></p>\n<p>This is amazing, the compiler is letting us know that we haven&#39;t handled the case of the <code>AddTodo</code> message and <code>Elm</code> has no idea what to do if that was to happen, so it&#39;s forcing us to deal with it immediately. Let&#39;s do that:</p>\n<pre><div class=\"copy-me\" onclick=\"copyCode(this)\">Copy</div><code><span class=\"hljs-title\">update</span> msg model =\n    <span class=\"hljs-keyword\">case</span> msg <span class=\"hljs-keyword\">of</span>\n        <span class=\"hljs-type\">UpdateInput</span> input -&gt;\n            { model | value = input }\n\n        <span class=\"hljs-type\">AddTodo</span> -&gt;\n            <span class=\"hljs-keyword\">case</span> model.value <span class=\"hljs-keyword\">of</span>\n                <span class=\"hljs-comment\">-- If the value of the input field is empty, do nothing</span>\n                <span class=\"hljs-string\">&quot;&quot;</span> -&gt;\n                    model\n\n                <span class=\"hljs-comment\">-- Whatever else the input field is set to, add it as a todo</span>\n                _ -&gt;\n                    { model\n                        | todos =\n                            <span class=\"hljs-comment\">-- Let&#x27;s update our todos field to include the new Todo item.</span>\n                            <span class=\"hljs-comment\">-- Its ID will be the number of todos at creation, its value</span>\n                            <span class=\"hljs-comment\">-- will be the value of our input and it will initially not</span>\n                            <span class=\"hljs-comment\">-- be marked as complete</span>\n                            { id = <span class=\"hljs-type\">List</span>.length model.todos, task = model.value, isComplete = <span class=\"hljs-type\">False</span> }\n                                <span class=\"hljs-comment\">-- (::) is a function in Elm that can be used to add something to the</span>\n                                <span class=\"hljs-comment\">-- front of a list</span>\n                                :: model.todos\n                    }</code></pre><p>Good. We&#39;re handling all the messages our app can pass at this stage. We&#39;re never firing the <code>AddTodo</code> message at the moment, let&#39;s implement that next and add a way to display our list of Todos:</p>\n<pre><div class=\"copy-me\" onclick=\"copyCode(this)\">Copy</div><code><span class=\"hljs-comment\">-- Make sure button is imported at the top for this step</span>\n<span class=\"hljs-keyword\">import</span> Html <span class=\"hljs-keyword\">exposing</span> (<span class=\"hljs-type\">Html</span>, button, div, input, text)\n\n<span class=\"hljs-comment\">-- And make sure the onClick event is included too</span>\n<span class=\"hljs-keyword\">import</span> Html.Events <span class=\"hljs-keyword\">exposing</span> (onClick, onInput)\n<span class=\"hljs-comment\">--...</span>\n\n<span class=\"hljs-comment\">-- Create a helper function to render our todos</span>\n<span class=\"hljs-title\">viewTodo</span> : <span class=\"hljs-type\">Todo</span> -&gt; <span class=\"hljs-type\">Html</span> <span class=\"hljs-type\">Msg</span>\n<span class=\"hljs-title\">viewTodo</span> t =\n    div [] [ text t.task ]\n\n<span class=\"hljs-title\">view</span> model =\n    div []\n        [ input [ onInput <span class=\"hljs-type\">UpdateInput</span> ] []\n        <span class=\"hljs-comment\">-- When we click the Add button, fire the AddTodo event</span>\n        , button [onClick <span class=\"hljs-type\">AddTodo</span>] [ text <span class=\"hljs-string\">&quot;Add&quot;</span> ]\n        <span class=\"hljs-comment\">-- Run all our todos through the viewTodo function</span>\n        , div [] (<span class=\"hljs-type\">List</span>.map viewTodo model.todos)\n        ]</code></pre><p>Run your app now and you should be able to type text into the input field and click add and you should see an increasing number of todos being added to the list.</p>\n<hr>\n<h1 id=\"summary\">Summary</h1>\n<p><code>Elm</code> is an excellent programming language in my opinion. The compiler really helps you out with extremely friendly error messages that tell you what you need to do to make it compile. Once it compiles, it&#39;s probably going to work.</p>\n<p>You can achieve close to no runtime errors by using Elm. Sure, writing the code up front might take a bit longer but Elms compiler really helps you when you need to refactor or fix bugs. <code>Elm</code> doesn&#39;t even have a concept of <code>null</code>! Everything must have a value.</p>\n<p>I think the barrier of entry to <code>Elm</code> is a big high, but if you have some basic functional programming experience and knowledge of HTML, CSS and JavaScript you should be able to create web apps with <code>Elm</code>.</p>\n<p>The repository for this app is here: <a href=\"https://github.com/simon-nystrom/basic-elm-todo\">https://github.com/simon-nystrom/basic-elm-todo</a>.</p>\n<p>I hope you found it interesting and that you&#39;ll try out <code>Elm</code> yourself!</p>\n","date":"2020-11-10","title":"Free of runtime errors with Elm","slug":"no-runtime-errors-elm","summary":"Learn about the basics of Elm and how it can help you eliminate runtime errors for good.","categories":[],"published":true,"tags":["elm","javascript"]}},"__N_SSG":true}